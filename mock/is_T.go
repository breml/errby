// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"sync"

	"github.com/elblox/errby"
)

// Ensure, that TMock does implement errby.T.
// If this is not the case, regenerate this file with moq.
var _ errby.T = &TMock{}

// TMock is a mock implementation of errby.T.
//
// 	func TestSomethingThatUsesT(t *testing.T) {
//
// 		// make and configure a mocked errby.T
// 		mockedT := &TMock{
// 			FailFunc: func()  {
// 				panic("mock out the Fail method")
// 			},
// 			FailNowFunc: func()  {
// 				panic("mock out the FailNow method")
// 			},
// 		}
//
// 		// use mockedT in code that requires errby.T
// 		// and then make assertions.
//
// 	}
type TMock struct {
	// FailFunc mocks the Fail method.
	FailFunc func()

	// FailNowFunc mocks the FailNow method.
	FailNowFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Fail holds details about calls to the Fail method.
		Fail []struct{}
		// FailNow holds details about calls to the FailNow method.
		FailNow []struct{}
	}
	lockFail    sync.RWMutex
	lockFailNow sync.RWMutex
}

// Fail calls FailFunc.
func (mock *TMock) Fail() {
	if mock.FailFunc == nil {
		panic("TMock.FailFunc: method is nil but T.Fail was just called")
	}
	callInfo := struct{}{}
	mock.lockFail.Lock()
	mock.calls.Fail = append(mock.calls.Fail, callInfo)
	mock.lockFail.Unlock()
	mock.FailFunc()
}

// FailCalls gets all the calls that were made to Fail.
// Check the length with:
//     len(mockedT.FailCalls())
func (mock *TMock) FailCalls() []struct{} {
	var calls []struct{}
	mock.lockFail.RLock()
	calls = mock.calls.Fail
	mock.lockFail.RUnlock()
	return calls
}

// FailNow calls FailNowFunc.
func (mock *TMock) FailNow() {
	if mock.FailNowFunc == nil {
		panic("TMock.FailNowFunc: method is nil but T.FailNow was just called")
	}
	callInfo := struct{}{}
	mock.lockFailNow.Lock()
	mock.calls.FailNow = append(mock.calls.FailNow, callInfo)
	mock.lockFailNow.Unlock()
	mock.FailNowFunc()
}

// FailNowCalls gets all the calls that were made to FailNow.
// Check the length with:
//     len(mockedT.FailNowCalls())
func (mock *TMock) FailNowCalls() []struct{} {
	var calls []struct{}
	mock.lockFailNow.RLock()
	calls = mock.calls.FailNow
	mock.lockFailNow.RUnlock()
	return calls
}
